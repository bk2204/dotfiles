[user]
	name = brian m. carlson
	signingkey = 1F52F68B!
[alias]
	# Checkout, recursing into submodules, however that's supported.
	co = "!f() { if git checkout -h | grep -qs recurse-submodules; \
		then git checkout --recurse-submodules \"$@\"; \
		else git checkout \"$@\" && git sui; \
		fi; };f"
	cor = "!f() { git co \"$@\"; };f"
	st = status
	pff = pull --ff-only
	pnff = pull --no-ff
	mff = merge --ff-only
	mnff = merge --no-ff
	amend = commit --amend --reset-author
	update = commit --amend --reset-author --no-edit
	los = log --simplify-merges --topo-order
	lops = log -p -C --simplify-merges --topo-order
	lowps = log -p -C --simplify-merges --topo-order --word-diff
	gr = log --graph --decorate
	grs = log --graph --decorate --simplify-merges
	sui = submodule update --init
	# Word diff.
	wdiff = diff --word-diff
	# Word diff staged changes
	wdiffc = diff --word-diff --cached
	# Diff staged changes.
	diffc = diff --cached
	# Stash changes, keeping the index unmodified.
	stake = stash save --keep-index
	# Full rebase, using merge strategies and autosquashing.
	frebase = rebase -m -i --autosquash
	# Noninteractive rebase with merge strategies and autosquashing.
	srebase = "!f() { GIT_SEQUENCE_EDITOR=/bin/true git rebase -m -i --autosquash \"$@\"; };f"
	# Rebase using merge strategies.
	mrebase = rebase -m
	# List the original commit currently being rebased.
	mrcommit = "!f() { local gd=\"$(git rev-parse --git-dir)\"; cat \"$gd/rebase-merge/cmt.$(cat \"$gd/rebase-merge/msgnum\")\"; };f"
	# List the commit message for the commit currently being rebased.
	mrmsg = "!f() { git log -1 $(git mrcommit); };f"
	# Import a tarball in such a way as to produce predictable SHA-1 values.
	setup = "!f() { git init && git add -f . && GIT_COMMITTER_DATE=451521442 GIT_AUTHOR_DATE=451521442 git commit -m 'initial import' && git tag start; };f"
	# Import patches in such a way as to produce predictable SHA-1 values.
	import-patches = "!f() { GIT_COMMITTER_DATE=451521442 GIT_AUTHOR_DATE=451521442 git am -3 \"$@\"; };f"
	lsf = ls-files
	# List files matching a grep pattern.
	lsg = "!f() { git ls-files | grep \"$@\"; };f"
	# Exits zero if the two treeishes are the same, nonzero otherwise.
	same-tree = "!f() { git diff-tree --exit-code \"$@\" >/dev/null; };f"
[i18n]
	commitencoding = UTF-8
[repack]
	UseDeltaBaseOffset = true
[transfer]
	unpackLimit = 5
[url "https://bmc@git.crustytoothpaste.net/git/bmc/"]
	insteadOf = dct:
[url "git@git.crustytoothpaste.net:/bmc/"]
	insteadOf = dcts:
[url "git@github.com:bk2204/"]
	insteadOf = gh:
[url "https://github.com/"]
	insteadOf = ghp:
[push]
	default = matching
[pull]
	rebase = false
[color]
	ui = auto
[color.diff]
	new = 34
	old = 203
[sendemail]
	smtpuser = bmc
	smtppass =
	smtpencryption = tls
	smtpserver = mail.crustytoothpaste.net
	smtpserverport = 587
	suppresscc = author
	suppresscc = self
	suppresscc = sob
	assume8bitEncoding = UTF-8
	confirm = always
	composeencoding = UTF-8
	chainreplyto = false
[diff]
	renames = copies
	algorithm = histogram
	indentheuristic = true
	wserrorhighlight = old,new
	tool = gvimdiff
[merge]
	conflictstyle = diff3
[submodule]
	fetchjobs = 4
[core]
	precomposeunicode = true
	logAllRefUpdates = true
[rerere]
	enabled = true
[log]
	decorate = false
[advice]
	ignoredHook = false
# vim: set noet:
