# bmc prompt theme, based off of the clint prompt theme from zsh 4.3.2-7.
# Yes, this does look like angry fruit salad, but I like it that way.

prompt_bmc_help () {
	cat <<'EOF'

	prompt bmc
EOF
}

prompt_bmc_want_bold () {
	local text=$1

	[ -z "$text" ] && return 1;
	for i in no off false regular normal non-bold;
	do
		[ "$text" = "$i" ] && return 1
	done
	return 0;
}

prompt_bmc_setup_colors () {
	local number=$1
	local ffont=$2
	local fcolor=$3
	local fbold=$(prompt_bmc_want_bold $ffont && echo "yes")

	printf 'pcc[%s]="%s"' $number $(color_fg $fcolor $fbold)
}

# hostname, FQDN if possible, without the trailing newline.
prompt_bmc_hostname () {
	(hostname -f 2>/dev/null || hostname 2>/dev/null || printf localhost) | tr -d '\n'
}

prompt_bmc_setup_base () {
	local -a pcc
	local i j
	local c_reset="%b%{$reset_color%}"
	local c_hostcolor=$(( $(echo "0x$(prompt_bmc_hostname | sha256sum | cut -b1-2)") ))

	j=0
	for i in "$@" "yes $c_hostcolor"
	do
		j=$((j + 1))
		# It breaks if you don't use the subshell echo.  I promise.
		eval $(prompt_bmc_setup_colors $j $(echo $i))
	done

	zstyle ':vcs_info:*' enable git
	zstyle ':vcs_info:*' actionformats "($pcc[10]%b|%a%$c_reset%)" "%R"
	zstyle ':vcs_info:*' formats       "($pcc[10]%b%$c_reset%)" "%R"

	local p_privuser="$pcc[4]%n$c_reset"
	local p_unprivuser="$pcc[8]%n$c_reset"
	local p_user="%(!.$p_privuser.$p_unprivuser)$pcc[1]@%m$c_reset"
	local p_pwd="$pcc[2]%~$c_reset"

	local p_userpwd="$p_user:$p_pwd"

	local p_priv="$pcc[4]#$c_reset"
	local p_unpriv="$pcc[3]%%$c_reset"

	local p_pchar="%(!.$p_priv.$p_unpriv)"

	# Don't use the %D by itself, because it uses two-digit years.
	local p_date="$pcc[5]%D{%Y-%m-%d}$c_reset"
	# Similarly, don't use %* by itself, because it is not zero-padded.
	local p_time="$pcc[5]%D{%H:%M:%S}$c_reset"

	local p_datetime="$p_date/$p_time"

	local p_tty="$pcc[7]%l$c_reset"

	local p_shlvl="%(2L.($pcc[7]%L$c_reset).)"
	local p_power="%(2V.($pcc[7]%2v$c_reset).)"

	local p_failed="$pcc[6]failed$c_reset"
	local p_retcode="$pcc[6]%?$c_reset"
	local p_signame="$pcc[6]%1v$c_reset"
	local p_mode='${psvar[3]:-%(?.ok.no)}'

	local p_ret="%(?.ok.$p_failed:$p_retcode:$p_signame)"
	local p_ret2="$pcc[9]%m $p_mode$c_reset"

	local p_branch='${${vcs_info_msg_1_/$HOME}:+${vcs_info_msg_0_}}'

	POSTEDIT="$reset_color"

	prompt="$p_userpwd$p_branch
($p_datetime)($p_hostname$p_tty)$p_shlvl$p_power($p_ret)
$p_ret2 $p_pchar "
	RPROMPT=""
	PS2='%(4_.\.)%3_> %E'

	if [[ -d /sys/class/power_supply ]] && [[ ! -f "$HOME/.slowbox" ]]
	then
		precmd () { prompt_bmc_precmd; prompt_bmc_apm_precmd }
	else
		precmd () { prompt_bmc_precmd }
	fi
	preexec () { }
}

prompt_bmc_setup () {
	if echotc Co >/dev/null 2>&1 && [[ $(echotc Co) = 256 ]]
	then
		prompt_bmc_setup_base \
			"yes 33" \
			"yes 40" \
			"yes 15" \
			"yes 9" \
			"yes 104" \
			"yes 9" \
			"yes 15" \
			"yes 33" \
			"no  33" \
			"no  33"
	else
		prompt_bmc_setup_base \
			"yes blue" \
			"yes green" \
			"yes white" \
			"yes red" \
			"yes magenta" \
			"yes red" \
			"yes white" \
			"yes blue" \
			"no  cyan" \
			"no  cyan"
	fi

	choose_prompt "main"
}

# In this function, we have to put the setopt after the exitstatus assignment,
# otherwise we get the result of the setopt (AFAIK, always 0) which is obviously
# not very useful.
prompt_bmc_precmd () {
	local exitstatus=$?
	setopt noxtrace localoptions

	if [[ $exitstatus -ge 128 ]]
	then
		psvar[1]="$signals[$exitstatus-127]"
	else
		psvar[1]="none"
	fi

	local curstatus
	[[ -n $TMUX ]] && curstatus="$(tmux display-message -p '#W')"

	# Update prompt unless the title starts with a ZWSP (U+200B) or colon.
	if printf "%s\n" "$curstatus" | grep -Eqvs "^($(printf '\342\200\213')|:)"
	then
		local statusline='%n@%m: %~'
		case $TERM in
			xterm*|gnome*)
				print -Pn "\e]0;$statusline\a";;
			screen*)
				print -Pn "\ek$statusline\e\\";;
		esac
	fi

	prompt_bmc_need_refresh && command -v vcs_info >/dev/null 2>&1 && vcs_info
}

prompt_bmc_need_refresh () {
	local last="$(fc -ln -1)"
	[[ -f "$HOME/.slowbox" ]] || return 0
	# If we're on a slow box, we want to refresh on cd, pushd, popd, git, and
	# empty text.
	[[ -z ${last/cd*} ]] && return 0
	[[ -z ${last/pushd*} ]] && return 0
	[[ -z ${last/popd*} ]] && return 0
	[[ -z ${last/git*} ]] && return 0
	[[ -z $last ]] && return 0
	return 1
}

prompt_bmc_apm_precmd () {
	setopt noxtrace localoptions
	local bat ac
	local bat_now bat_full
	local has_ac has_bat

	has_ac=0
	has_bat=0

	if [ -d /sys/class/power_supply/AC ];
	then
		[ $(</sys/class/power_supply/AC/online) = 1 ] && has_ac=1
	fi
	if [ -d /sys/class/power_supply/BAT0 ];
	then
		has_bat=1

		if [ -r /sys/class/power_supply/BAT0/charge_now ];
		then
			bat_now=$(</sys/class/power_supply/BAT0/charge_now)
			bat_full=$(</sys/class/power_supply/BAT0/charge_full)
		else
			bat_now=$(</sys/class/power_supply/BAT0/energy_now)
			bat_full=$(</sys/class/power_supply/BAT0/energy_full)
		fi

		bat=$((100 * bat_now / bat_full))"%"
	fi
	[ $has_ac = 1 ] && ac="ac"
	[ $has_bat = 1 ] && [ $has_ac = 1 ] && ac="ac+"

	if [[ $has_ac = 0 ]] && [[ $has_bat = 0 ]]
	then
		psvar[2]=()
	else
		psvar[2]="$ac$bat"
	fi
}

prompt_bmc_setup "$@"

# vim: set filetype=zsh:
