# bmc prompt theme, based off of the clint prompt theme from zsh 4.3.2-7.
# Yes, this does look like angry fruit salad, but I like it that way.

prompt_bmc_help () {
	cat <<'EOF'

	prompt bmc
EOF
}

prompt_bmc_want_bold ()
{
	text=$1

	[ -z "text" ] && return 1;
	for i in no off false regular normal non-bold;
	do
		[ "$text" = "$i" ] && return 1
	done
	return 0;
}

prompt_bmc_setup_colors ()
{
	local number=$1
	local ffont=$2
	local fcolor=$3
	local fbold=$(prompt_bmc_want_bold $ffont && echo "yes")

	printf 'pcc[%s]="%s"' $number $(color_fg $fcolor $fbold)
}

prompt_bmc_setup_base ()
{
	local -a pcc
	local p_user p_pwd p_date p_time p_failed p_retcode p_signame p_priv p_unpriv
	local p_userpwd p_datetime p_tty p_ret p_pchar p_status p_branch
	local p_shlvl
	local p_power
	local p_mode

	local i j

	c_reset="%b%{$reset_color%}"

	j=0
	for i in "$@"
	do
		j=$((j + 1))
		# It breaks if you don't use the subshell echo.  I promise.
		eval $(prompt_bmc_setup_colors $j $(echo $i))
	done

	zstyle ':vcs_info:*' actionformats "($pcc[10]%b|%a%$c_reset%)" "%R"
	zstyle ':vcs_info:*' formats       "($pcc[10]%b%$c_reset%)" "%R"
	zstyle ':vcs_info:(sv[nk]|bzr):*' branchformat "%b:%r"

	p_privuser="$pcc[4]%n$c_reset"
	p_unprivuser="$pcc[8]%n$c_reset"
	p_user="%(!.$p_privuser.$p_unprivuser)$pcc[1]@%m$c_reset"
	p_pwd="$pcc[2]%~$c_reset"

	p_userpwd="$p_user:$p_pwd"

	p_priv="$pcc[4]#$c_reset"
	p_unpriv="$pcc[3]%%$c_reset"

	p_pchar="%(!.$p_priv.$p_unpriv)"

	# Don't use the %D by itself, because it uses two-digit years.
	p_date="$pcc[5]%D{%Y-%m-%d}$c_reset"
	# Similarly, don't use %* by itself, because it is not zero-padded.
	p_time="$pcc[5]%D{%H:%M:%S}$c_reset"

	p_datetime="$p_date/$p_time"

	p_tty="$pcc[7]%l$c_reset"

	p_shlvl="%(2L.($pcc[7]%L$c_reset).)"
	p_power="%(2V.($pcc[7]%2v$c_reset).)"

	p_failed="$pcc[6]failed$c_reset"
	p_retcode="$pcc[6]%?$c_reset"
	p_signame="$pcc[6]%1v$c_reset"
	p_mode='${psvar[3]:-%(?.ok.no)}'

	p_ret="%(?.ok.$p_failed:$p_retcode:$p_signame)"
	p_ret2="$pcc[9]%m $p_mode$c_reset"

	p_branch='${${vcs_info_msg_1_/$HOME}:+${vcs_info_msg_0_}}'

	#[[ -f /proc/apm ]] && p_apm="%(2v.-%2v-.)"

	POSTEDIT="$reset_color"

	prompt="$p_userpwd$p_branch
($p_datetime)($p_tty)$p_shlvl$p_power($p_ret)
$p_ret2 $p_pchar "
	RPROMPT=""
	PS2='%(4_.\.)%3_> %E'

	[[ -d /sys/class/power_supply ]] &&
		precmd () { prompt_bmc_precmd ; prompt_bmc_apm_precmd } ||
		precmd () { prompt_bmc_precmd }
	preexec () { }
}

prompt_bmc_setup ()
{
	if echotc Co >/dev/null 2>/dev/null && [[ $(echotc Co) = 256 ]]
	then
		prompt_bmc_setup_base \
			"yes 33" \
			"yes 40" \
			"yes 15" \
			"yes 9" \
			"yes 104" \
			"yes 9" \
			"yes 15" \
			"yes 33" \
			"no  33" \
			"no  33"
	else
		prompt_bmc_setup_base \
			"yes blue" \
			"yes green" \
			"yes white" \
			"yes red" \
			"yes magenta" \
			"yes red" \
			"yes white" \
			"yes blue" \
			"no  cyan" \
			"no  cyan"
	fi

	choose_prompt "main"
}

# In this function, we have to put the setopt after the exitstatus assignment,
# otherwise we get the result of the setopt (AFAIK, always 0) which is obviously
# not very useful.
prompt_bmc_precmd () {
	local exitstatus=$?
	setopt noxtrace localoptions

	[[ $exitstatus -ge 128 ]] && psvar[1]="$signals[$exitstatus-127]" || psvar[1]="none"

	local statusline='%n@%m: %~'
	case $TERM in
		xterm*|gnome*)
			print -Pn "\e]0;$statusline\a";;
		screen*)
			print -Pn "\ek$statusline\e\\";;
	esac

	command -v vcs_info >/dev/null 2>/dev/null && vcs_info
}

prompt_bmc_apm_precmd () {
	setopt noxtrace localoptions
	local bat ac
	local bat_now bat_full
	local has_ac has_bat

	has_ac=0
	has_bat=0

	if [ -d /sys/class/power_supply/AC ];
	then
		[ $(</sys/class/power_supply/AC/online) = 1 ] && has_ac=1
	fi
	if [ -d /sys/class/power_supply/BAT0 ];
	then
		has_bat=1

		if [ -r /sys/class/power_supply/BAT0/charge_now ];
		then
			bat_now=$(</sys/class/power_supply/BAT0/charge_now)
			bat_full=$(</sys/class/power_supply/BAT0/charge_full)
		else
			bat_now=$(</sys/class/power_supply/BAT0/energy_now)
			bat_full=$(</sys/class/power_supply/BAT0/energy_full)
		fi

		bat=$((100 * bat_now / bat_full))"%"
	fi
	[ $has_ac = 1 ] && ac="ac"
	[ $has_bat = 1 ] && [ $has_ac = 1 ] && ac="ac+"

	[[ $has_ac = 0 ]] && [[ $has_bat = 0 ]] && psvar[2]=() || psvar[2]="$ac$bat"
}

prompt_bmc_setup "$@"

# vim: set filetype=zsh:
