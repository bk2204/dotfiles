# bmc prompt theme, based off of the clint prompt theme from zsh 4.3.2-7.
# Yes, this does look like angry fruit salad, but I like it that way.

prompt_bmc_help () {
	cat <<'EOF'

	prompt bmc [<color1> [<color2> [<color3> [<color4> [<color5>]]]]]

	defaults are green, blue, green, yellow, and white, respectively.

EOF
}

prompt_bmc_want_bold ()
{
	text=$1

	[ -z "text" ] && return 1;
	for i in no off false regular normal non-bold;
	do
		[ "$text" = "$i" ] && return 1
	done
	return 0;
}

prompt_bmc_boldness ()
{
	if prompt_bmc_want_bold $1
	then
		printf '%%B'
	else
		printf '%%F'
	fi
	#prompt_bmc_want_bold $1 && printf '%%B'
}

prompt_bmc_setup_colors ()
{
	number=$1
	ffont=$2
	fcolor=$3
	bfont=$4
	bcolor=$5

	printf 'pcc[%s]=' $number
	prompt_bmc_boldness $ffont
	printf '%%F{%s' $fcolor
	if [ -n "$bcolor" ]
	then
		printf '$bg_'
		prompt_bmc_boldness $bfont
		# Originally had printf '%sbold[%s]' $bcolor, but that was probably a
		# typo.
		printf 'bold[%s]' $bcolor
	fi
	printf '%%}\n'
}

prompt_bmc_setup_base ()
{
	local -a pcc
	local p_user p_pwd p_date p_time p_failed p_retcode p_signame p_priv p_unpriv
	local p_userpwd p_datetime p_tty p_ret p_pchar p_status p_branch
	local p_shlvl
	local p_power
	
	local i j

	c_reset="%b%{$reset_color%}"

	j=0
	for i in "$@"
	do
		j=$((j + 1))
		# It breaks if you don't use the subshell echo.  I promise.
		eval `prompt_bmc_setup_colors $j $(echo $i)`
	done

	zstyle ':vcs_info:*' actionformats "(%b|%a%)" "%R"
	zstyle ':vcs_info:*' formats       "(%b%)" "%R"
	zstyle ':vcs_info:(sv[nk]|bzr):*' branchformat "%b:%r"

	p_privuser="$pcc[4]%n$c_reset"
	p_unprivuser="$pcc[8]%n$c_reset"
	p_user="%(!.$p_privuser.$p_unprivuser)$pcc[1]@%m$c_reset"
	p_pwd="$pcc[2]%~$c_reset"

	p_userpwd="$p_user:$p_pwd"

	p_priv="$pcc[4]#$c_reset"
	p_unpriv="$pcc[3]%%$c_reset"

	p_pchar="%(!.$p_priv.$p_unpriv)"

	# Don't use the %D by itself, because it uses two-digit years.
	p_date="$pcc[5]%D{%Y-%m-%d}$c_reset"
	# Similarly, don't use %* by itself, because it is not zero-padded.
	p_time="$pcc[5]%D{%H:%M:%S}$c_reset"

	p_datetime="$p_date/$p_time"

	p_tty="$pcc[7]%l$c_reset"

	p_shlvl="%(2L.($pcc[7]%L$c_reset).)"
	p_power="%(2v.($pcc[7]%2v$c_reset).)"

	p_failed="$pcc[6]failed$c_reset"
	p_retcode="$pcc[6]%?$c_reset"
	p_signame="$pcc[6]%1v$c_reset"

	p_ret="%(?.ok.$p_failed:$p_retcode:$p_signame)"
	p_ret2="$pcc[9]%m %(?.ok.no)$c_reset"

	p_branch='${${vcs_info_msg_1_/$HOME}:+${vcs_info_msg_0_}}'

	#[[ -f /proc/apm ]] && p_apm="%(2v.-%2v-.)"

	POSTEDIT="$reset_color"

	prompt="$p_userpwd%(!..$p_branch)
($p_datetime)($p_tty)$p_shlvl$p_power($p_ret)
$p_ret2 $p_pchar "
	RPROMPT=""
	PS2='%(4_.\.)%3_> %E'

	[[ -d /sys/class/power_supply ]] &&
		precmd () { prompt_bmc_precmd ; prompt_bmc_apm_precmd } ||
		precmd () { prompt_bmc_precmd }
	preexec () { }
}

prompt_bmc_setup ()
{
	if [ $(echotc Co) = 256 ]
	then
		prompt_bmc_setup_base \
			"yes 33" \
			"yes 40" \
			"yes 15" \
			"yes 9" \
			"yes 104" \
			"yes 9" \
			"yes 15" \
			"yes 33" \
			"no 33"
	else
		prompt_bmc_setup_base \
			"yes blue" \
			"yes green" \
			"yes white" \
			"yes red" \
			"yes magenta" \
			"yes red" \
			"yes white" \
			"yes blue" \
			"no  cyan"
	fi
}

# In this function, we have to put the setopt after the exitstatus assignment,
# otherwise we get the result of the setopt (AFAIK, always 0) which is obviously
# not very useful.
prompt_bmc_precmd () {
	local exitstatus=$?
	setopt noxtrace localoptions

	[[ $exitstatus -ge 128 ]] && psvar[1]="$signals[$exitstatus-127]" || psvar[1]="none"

	vcs_info

	# Don't bother printing the jobs all of the time.
	#[[ -o interactive ]] && jobs -l

}

prompt_bmc_apm_precmd () {
	setopt noxtrace localoptions
	local bat ac
	local bat_now bat_full
	local has_ac has_bat

	has_ac=0
	has_bat=0

	if [ -d /sys/class/power_supply/AC ];
	then
		[ $(</sys/class/power_supply/AC/online) = 1 ] && has_ac=1
	fi
	if [ -d /sys/class/power_supply/BAT0 ];
	then
		has_bat=1
		bat_now=$(</sys/class/power_supply/BAT0/energy_now)
		bat_full=$(</sys/class/power_supply/BAT0/energy_full)

		bat=$((100 * bat_now / bat_full))"%"
	fi
	[ $has_ac = 1 ] && ac="ac"
	[ $has_bat = 1 ] && [ $has_ac = 1 ] && ac="ac+"

	#bat=${${="$(</proc/apm)"}[7]/%/%%}
	#[[ ${${="$(</proc/apm)"}[4]} == "0x01" ]] && ac="AC+"

	[[ $has_ac = 0 ]] && [[ $has_bat = 0 ]] && psvar[2]=() || psvar[2]="$ac$bat"
}

prompt_bmc_setup "$@"

# vim:set filetype=zsh:
