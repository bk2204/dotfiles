#!/bin/sh -e

summary=
quiet=
show=

while true
do
    case "$1" in
        --help|-h)
            cat <<-EOM
git at [--summary] [--show] [--quiet] [REVISION] REGEX

Print the object ID of the first commit matching the regex.

If REVISION is not specified, it defaults to HEAD.

If --summary is specified, look only in the commit summary.

If --quiet is specified, exit non-zero silently if no revision is found.

If --show is specified, instead of printing the revision, pass it to "git show".
EOM
            exit 0;;
        --summary)
            summary=t
            shift;;
        --show)
            show=t
            shift;;
        --quiet)
            quiet=--quiet
            shift;;
        *)
            break;;
    esac
done

if [ $# -eq 1 ]
then
    revision=HEAD
    regex="$1"
else
    revision="$1"
    regex="$2"
fi

# This behavior is tricky.  We cannot write "\n" inside an ERE, since POSIX EREs
# do not allow escapes of this type; we must instead insert a literal newline.
# We cannot do so with a simple printf of a newline, since command substitution
# strips trailing newlines.  Instead, insert the entire character class in with
# printf, which sidesteps these problems.
[ -z "$summary" ] || regex="^$(printf "[^\n]")*$regex"

rev=$(git rev-parse $quiet --verify "${revision}^{/$regex}")
if [ -n "$show" ]
then
    git show "$rev"
else
    echo $rev
fi
